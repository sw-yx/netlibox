# TITLE @TODO

My current process for writing and publishing content to the web using a static site generator looks like this:

1. Open a text file in my project repo on my laptop
2. Write/edit content
3. Save file
4. Stage and commit file using git
5. Push changes to remote repo
6. Changes are automatically deployed to live site

This process works pretty well, but I’ve been searching for an even more low-friction process.

When it comes to writing for the web and managing content, I love plain-text files written in markdown. For me, there’s nothing more simple, portable, longevous, or easily editable across operating systems and devices.

I found myself in a situation where I began asking: look I have a collection of plain text files here which represent the state of my blog. When I create a new text file (or edit an existing one) and then save it, why can’t that be the equivalent of hitting “Publish”? Well I’m here to tell you it can.

First, let me tell you which technologies I’m leveraging:

- Github (for code)
- Jekyll (for static site generation)
- Dropbox (for content)
- Netlify (for build tool + host)

These technologies work in concert to cut even more steps out of my process, making writing and publishing content to the web an act of editing and saving a text file.

First, I use Dropbox to manage a bunch of plain-text markdown files. Why Dropbox? Because of cross-platform sync. I can edit a plain-text markdown file on my laptop, a mobile device, or just about anywhere, and when that update is synced to Dropbox, I can configure a webhook to be sent from Dropbox to Netlify, triggering a new build. Then, my build process fetches my plain-text markdown files from Dropbox and builds my static site with the most up-to-date content.

In other words, the simple act of “saving” a file kicks off a process which builds and publishes my site to the web with the latest content. When I update content, I don’t even have to _think_ about committing, building, or deploying my site. I merely edit and save plain-text files. With Netlify, my production site is a function of my content: plain-text files. A picture is worth a thousand words, so allow me to illustrate:

![Graphic of process for editing and publishing content from Dropbox to Netlify](https://i.imgur.com/SNXUKF5.png)

Here’s my newly revised process for writing and publishing content to the web using a static site generator:

1. Open a text file ~~in my project repo on my laptop~~ on any device
2. Write/edit content
3. Save file
4. ~~Stage and commit file using git~~
5. ~~Push changes to remote repo~~
6. Changes are automatically deployed to live site

You can dive right into the code behind how this works by looking at my simple starter repo: [Netlibox](https://github.com/jimniels/netlibox) (it’s Netlify + Dropbox, I know, naming is hard). Or, check out the demo site that gets generated by visiting [netlibox.netlify.com](https://netlibox.netlify.com)

## The Nuts and Bolts

I briefly covered what technologies I’m using to achieve my simplified process for writing and publishing content to the web, but allow me to expand a little more.

### Git + Static Site Generator (Github + Jekyll)

For my static site, I have a git repo in Github where I store the HTML, CSS, JavaScript, and other configuration files which constitute the code of my site. Quite often, the plain-text markdown files of your content would also live in your git repo, but I abstracted those into a separate space (Dropbox) and pull them in at build time.

To generate a site, you’ll need some framework for generating a static site. You could use anything you want here, but for [my example](https://github.com/jimniels/netlibox), I use [Jekyll](https://jekyllrb.com) because its probably the most familiar to the most people (plus its easy to setup with little configuration).

The key difference here is that, rather than have a `_posts` folder with a bunch of markdown files ([as dictated by Jekyll](<(https://jekyllrb.com/docs/posts/)>)) directly in my git repo, I create that folder and its contents at build time by pulling all my plain-text markdown files from Dropbox. This is done via [a custom node script](https://github.com/jimniels/netlibox/blob/master/scripts/get-posts-from-dropbox.js) that gets run before Jekyll does its thing. For example, rather than your build command being `jekyll build` you would do something like `node fetch-posts.js && jekyll build`.

### Dropbox + Netlify

In Dropbox, you can [create an app](https://www.dropbox.com/developers/apps/create) which is essentially a way of getting programmatic access via the API to files inside your Dropbox. In my case, I created a new app with its own folder, which is advantageous because your associated API tokens will automatically scope access to that specific folder (as opposed to your entire Dropbox). This folder is essentially my Jekyll `_posts` folder that gets pulled in at build time.

Once you have an “app” in Dropbox, you can enable [webhooks](https://www.dropbox.com/developers/reference/webhooks) for that app:

> Webhooks are a way for web apps to get real-time notifications when users' files change in Dropbox.
> Once you register a URI to receive webhooks, Dropbox will send an HTTP request to that URI every time there's a change

Netlify allows you to generate [incoming webhooks](https://www.netlify.com/docs/webhooks/#incoming-webhooks) which give you a unique URL you can use to trigger a build of your site. At first glance, the integration between Dropbox and Netlify seems quite simple: add the incoming webhook URI Netlify generates for you to your Dropbox app, then Dropbox will ping that Netlify URI to trigger a build every time a file changes. However, it’s not quite so straightforward.

Dropbox requires you to [register your URI via a “verification request”](https://www.dropbox.com/developers/reference/webhooks#documentation):

> The first request to your new webhook URI will be a verification request to confirm that Dropbox is communicating with the right service.
> The verification request will be a GET request with a challenge parameter, which is a random string...Your app should echo back the challenge parameter as the body of its response. Once Dropbox receives a valid response, the endpoint is considered to be a valid webhook, and Dropbox will begin sending notifications of file changes.

In other words, Dropbox wants to know that the URI you enter to receive HTTP requests is expecting these requests and that you, therefore, control the endpoint. The incoming webhook URI that Netlify gives you cannot do that. It merely listens for a `POST` request, then triggers a build if it gets one. But Dropbox won’t send a `POST` request until it verifies the endpoint by getting a response it expects. So now what?

This is the point at which you might think “well, this whole JAMstack thing is great, but you’ll always find yourself needing a server for something.” But guess what? Netlify can solve this problem for you with its incredibly convenient [functions](https://www.netlify.com/docs/functions/) and [redirects](https://www.netlify.com/docs/redirects/) features.

In this particular case, I was able to verify my URI through the Dropbox API by using a [proxy redirect in Netlify](https://www.netlify.com/docs/redirects/). To summarize, the redirect proxies Dropbox’s one-time verification request to [my custom Netlify function endpoint](https://github.com/jimniels/netlibox/blob/master/src/_netlify-functions/dropbox-webhook.js) which responds to Dropbox with the expected response. In turn, my URI is now considered verified with Dropbox and will begin receiving `POST` requests when files change. At that point, I change my redirect to proxy to an [incoming webhook](https://www.netlify.com/docs/webhooks/) URI I generate through Netlify which, when it receives a `POST` request, triggers a new build. The end result is that anytime there is a file change in my Dropbox folder, the Dropbox API will ping my URI and a build will be triggered in Netlify so that the site is automatically built and deployed to production with the latest content. The best part is you only end up using a single function invocation which is way beneath the free pricing tier (ok let’s be honest, it took _a couple_ function invocations because I had to test, who gets their code right the first time?)

## Conclusion

Netlify is amazing for many reasons, but in this particular case, it gave me tools that previously would’ve been too complicated for me to setup and maintain on my own. Because I now have these additional tools, the size of what’s possible for me to build on my own has increased. This is one of the reason I love Netlify: it grows the possibilities for me to create whatever I can envision.

In this particular case, Netlify gives me control over my build process such that I can abstract my content from my code then pull it in at build time. On top of that, I can automate the triggering of builds based on when a file is edited or saved, so I don’t have to worry about building/deploying a website. I just create and edit plain-text markdown files, and I can trust the current state of those files at any point in time represents my live website.

Checkout [Netlibox on Github](https://github.com/jimniels/netlibox) to learn more or try this out yourself.
